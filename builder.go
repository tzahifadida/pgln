// Package pgln provides functionality for PostgreSQL LISTEN/NOTIFY operations.
package pgln

import (
	"context"
	"errors"
	"fmt"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"sync"
	"time"
)

// NotifyQueryResult represents the result of a NotifyQuery call.
type NotifyQueryResult struct {
	Query  string // The SQL query to be executed
	Params []any  // The parameters for the query
}

// PGListenNotify handles listening and notifying operations.
// It is generated by the Builder.
type PGListenNotify struct {
	connectionString   string
	reconnectInterval  time.Duration
	connectTimeout     time.Duration
	healthCheckTimeout time.Duration
	pool               *pgxpool.Pool
	ctx                context.Context
	channels           map[string]*ListenOptions
	channelsChanged    bool
	lock               sync.RWMutex
	error              error
	cancelContextFunc  context.CancelFunc
	ownChannel         string
	started            bool
}

type pgListenNotifyBuilder struct {
	r *PGListenNotify
}

// NotificationCallbackType is a function type for handling notifications.
type NotificationCallbackType func(channel string, payload string)

// DoneCallbackType is a function type called when listening is done.
type DoneCallbackType func(channel string)

// ErrorCallbackType is a function type for handling errors.
type ErrorCallbackType func(channel string, err error)

// OutOfSyncBlockingCallbackType is a function type for handling out-of-sync situations.
type OutOfSyncBlockingCallbackType func(channel string) error

// ListenOptions is used when Listen is called. It also maintains internal state.
type ListenOptions struct {
	// NotificationCallback is an optional BLOCKING callback that is called for each channel when a notification arrives.
	// Blocking means that we leave it up to the callback to decide if everything should wait or to spawn a goroutine.
	NotificationCallback NotificationCallbackType
	// DoneCallback is an optional BLOCKING callback that is called for each channel when we are done listening.
	// Blocking means that we leave it up to the callback to decide if everything should wait or to spawn a goroutine.
	DoneCallback DoneCallbackType

	// ErrorCallback is an optional BLOCKING callback that is called for each channel when there is an unexpected error.
	// Blocking means that we leave it up to the callback to decide if everything should wait or to spawn a goroutine.
	ErrorCallback ErrorCallbackType
	// OutOfSyncBlockingCallback is an optional BLOCKING callback that is called for each channel when we first connect
	// and when we reconnect. It is called just before receiving the first notification.
	// It allows you to catch up or rebuild your caches while we are listening for new notifications, so you do not lose your messages
	// while rebuilding.
	// Blocking means that we leave it up to the callback to decide if everything should wait or to spawn a goroutine.
	OutOfSyncBlockingCallback OutOfSyncBlockingCallbackType
	channel                   string
	executedListen            bool
	unListenRequested         bool
	listeningStarted          chan error
	unListenComplete          chan struct{}
	listeningStartedMu        sync.Mutex
	listeningStartedClosed    bool
}

// PGListenNotifyBuilder builds a PGListenNotify structure you can use to listen for new notifications.
type PGListenNotifyBuilder interface {
	// SetContext allows you to set your own custom context, so we can stop listening when the context is done.
	SetContext(ctx context.Context) PGListenNotifyBuilder

	// UseConnectionString sets a pgxpool supported connection string. You must specify either a pool or a connection string.
	UseConnectionString(connectionString string) PGListenNotifyBuilder
	// SetPool allows you to set or reuse your custom pool. You must specify either a pool or a connection string.
	SetPool(pool *pgxpool.Pool) PGListenNotifyBuilder

	// SetReconnectInterval sets the interval in milliseconds to wait between reconnection attempts.
	SetReconnectInterval(reconnectInterval time.Duration) PGListenNotifyBuilder

	// SetConnectTimeout sets the timeout for connecting to the database.
	SetConnectTimeout(timeout time.Duration) PGListenNotifyBuilder

	// SetHealthCheckTimeout sets the timeout for health check operations.
	SetHealthCheckTimeout(timeout time.Duration) PGListenNotifyBuilder

	// Build is the final call to construct the PGListenNotify structure.
	Build() (*PGListenNotify, error)
}

// SetReconnectInterval sets the interval for reconnection attempts.
func (rb *pgListenNotifyBuilder) SetReconnectInterval(reconnectInterval time.Duration) PGListenNotifyBuilder {
	if rb.r.error != nil {
		return rb
	}
	if reconnectInterval <= 0 {
		rb.r.error = errors.New("reconnectInterval must be greater than 0")
	}
	rb.r.reconnectInterval = reconnectInterval
	return rb
}

// SetConnectTimeout sets the timeout for connecting to the database.
func (rb *pgListenNotifyBuilder) SetConnectTimeout(timeout time.Duration) PGListenNotifyBuilder {
	if rb.r.error != nil {
		return rb
	}
	if timeout <= 0 {
		rb.r.error = errors.New("connectTimeout must be greater than 0")
	}
	rb.r.connectTimeout = timeout
	return rb
}

// SetHealthCheckTimeout sets the timeout for health check operations.
func (rb *pgListenNotifyBuilder) SetHealthCheckTimeout(timeout time.Duration) PGListenNotifyBuilder {
	if rb.r.error != nil {
		return rb
	}
	if timeout <= 0 {
		rb.r.error = errors.New("healthCheckTimeout must be greater than 0")
	}
	rb.r.healthCheckTimeout = timeout
	return rb
}

// SetContext sets the context for the PGListenNotify operations.
func (rb *pgListenNotifyBuilder) SetContext(ctx context.Context) PGListenNotifyBuilder {
	if rb.r.error != nil {
		return rb
	}
	rb.r.ctx = ctx
	return rb
}

// UseConnectionString sets the connection string for the database.
func (rb *pgListenNotifyBuilder) UseConnectionString(connectionString string) PGListenNotifyBuilder {
	if rb.r.error != nil {
		return rb
	}
	rb.r.connectionString = connectionString
	return rb
}

// SetPool sets the connection pool for the PGListenNotify operations.
func (rb *pgListenNotifyBuilder) SetPool(pool *pgxpool.Pool) PGListenNotifyBuilder {
	if rb.r.error != nil {
		return rb
	}
	rb.r.pool = pool
	return rb
}

// Build constructs and returns the PGListenNotify structure.
func (rb *pgListenNotifyBuilder) Build() (*PGListenNotify, error) {
	if rb.r.error != nil {
		return nil, rb.r.error
	}
	if rb.r.connectionString == "" && rb.r.pool == nil {
		return nil, errors.New("either connection string or pool must be provided")
	}
	if rb.r.ctx == nil {
		return nil, errors.New("context cannot be null")
	}
	if rb.r.reconnectInterval == 0 {
		rb.r.reconnectInterval = 5 * time.Second
	}
	if rb.r.connectTimeout == 0 {
		rb.r.connectTimeout = 30 * time.Second
	}
	if rb.r.healthCheckTimeout == 0 {
		rb.r.healthCheckTimeout = 5 * time.Second
	}
	randomUUID, err := uuid.NewRandom()
	if err != nil {
		return nil, fmt.Errorf("failed to generate UUID: %w", err)
	}
	rb.r.ownChannel = randomUUID.String()
	ctx, cancelFunc := context.WithCancel(rb.r.ctx)
	rb.r.ctx = ctx
	rb.r.cancelContextFunc = cancelFunc
	rb.r.channels = make(map[string]*ListenOptions)
	return rb.r, nil
}

// NewPGListenNotifyBuilder creates a new PGListenNotifyBuilder to configure the listener.
func NewPGListenNotifyBuilder() PGListenNotifyBuilder {
	return &pgListenNotifyBuilder{
		r: &PGListenNotify{
			ctx: context.Background(),
		},
	}
}

// Start begins the monitoring process. It should be called after Build().
func (r *PGListenNotify) Start() error {
	if r.started {
		return errors.New("PGListenNotify has already been started")
	}

	if r.pool == nil {
		// Create and ping the connection pool
		config, err := pgxpool.ParseConfig(r.connectionString)
		if err != nil {
			return fmt.Errorf("failed to parse connection string: %w", err)
		}

		config.ConnConfig.ConnectTimeout = r.connectTimeout
		config.HealthCheckPeriod = r.healthCheckTimeout

		ctx, cancel := context.WithTimeout(r.ctx, r.connectTimeout)
		defer cancel()

		r.pool, err = pgxpool.NewWithConfig(ctx, config)
		if err != nil {
			return fmt.Errorf("failed to create connection pool: %w", err)
		}
	}

	ctx, cancel := context.WithTimeout(r.ctx, r.healthCheckTimeout)
	defer cancel()

	err := r.pool.Ping(ctx)
	if err != nil {
		return fmt.Errorf("failed to ping the database: %w", err)
	}

	r.started = true
	go r.startMonitoring()
	return nil
}

// Shutdown releases resources that were created internally.
func (r *PGListenNotify) Shutdown() {
	r.lock.RLock()
	contextFunc := r.cancelContextFunc
	pool := r.pool
	r.lock.RUnlock()
	if contextFunc != nil {
		contextFunc()
	}
	if pool != nil {
		pool.Close()
	}
}

// UnListen stops listening for the specified channel.
// It returns a channel that will be closed when the unlisten operation is complete.
func (r *PGListenNotify) UnListen(channel string) (chan struct{}, error) {
	r.lock.Lock()
	defer r.lock.Unlock()
	options, ok := r.channels[channel]
	if !ok {
		return nil, fmt.Errorf("unlisten failed: channel not found: %s", channel)
	}
	if options.unListenRequested {
		return nil, fmt.Errorf("unlisten failed: channel already marked for unlisten: %s", channel)
	}

	options.unListenRequested = true
	if options.unListenComplete == nil {
		options.unListenComplete = make(chan struct{})
	}
	r.channelsChanged = true
	go r.wakeupOwnChannel()
	return options.unListenComplete, nil
}

// UnlistenAndWaitForUnlistening stops listening for the specified channel and waits until it's completely removed.
// This function is important for safe shutdown as it ensures that no more notifications will be processed for this channel.
func (r *PGListenNotify) UnlistenAndWaitForUnlistening(channel string) error {
	unlistenComplete, err := r.UnListen(channel)
	if err != nil {
		return fmt.Errorf("failed to initiate unlisten: %w", err)
	}

	select {
	case <-unlistenComplete:
		return nil
	case <-r.ctx.Done():
		return fmt.Errorf("unlisten wait interrupted: %w", r.ctx.Err())
	}
}

// wakeupOwnChannel releases the wait for notifications, so we can start listening for the new channel.
func (r *PGListenNotify) wakeupOwnChannel() {
	ticker := time.NewTicker(r.reconnectInterval + 1*time.Second)
	defer ticker.Stop()
	for {
		r.lock.RLock()
		channelsChanged := r.channelsChanged
		r.lock.RUnlock()
		if channelsChanged {
			_ = r.Notify(r.ownChannel, "new listener")
		} else {
			return
		}
		select {
		case <-r.ctx.Done():
			return
		case <-ticker.C:
		}
	}
}

// Listen will "listen" to a channel specified in the options.
// It returns a channel that will receive an error if there's a failure to listen.
// To stop listening for a channel, use UnListen.
func (r *PGListenNotify) Listen(channel string, options ListenOptions) (chan error, error) {
	if !r.started {
		return nil, errors.New("PGListenNotify has not been started")
	}
	optionsCopy := options
	optionsCopy.channel = channel
	optionsCopy.listeningStarted = make(chan error, 1)
	optionsCopy.listeningStartedClosed = false
	r.lock.Lock()
	defer r.lock.Unlock()
	r.channelsChanged = true
	r.channels[optionsCopy.channel] = &optionsCopy
	go r.wakeupOwnChannel()
	return optionsCopy.listeningStarted, nil
}

// ListenAndWaitForListening combines Listen and waiting for the listening to start.
// It returns an error if there was a failure in listening or if the context is cancelled.
func (r *PGListenNotify) ListenAndWaitForListening(channel string, options ListenOptions) error {
	errChan, err := r.Listen(channel, options)
	if err != nil {
		return err
	}

	select {
	case err := <-errChan:
		return err
	case <-r.ctx.Done():
		return nil
	}
}

// Notify allows you to send a notification to a specified channel with a payload.
func (r *PGListenNotify) Notify(channel string, payload string) error {
	conn, err := r.pool.Acquire(r.ctx)
	if err != nil {
		return fmt.Errorf("failed to acquire connection: %w", err)
	}
	defer conn.Release()
	_, err = conn.Exec(r.ctx, "SELECT pg_notify($1, $2)", channel, payload)
	if err != nil {
		return fmt.Errorf("failed to execute notify: %w", err)
	}
	return nil
}

// NotifyQuery returns the query string and parameters for notifying a channel.
// This allows the caller to run the query themselves in their own transaction.
// The main reason is that pg_notify is run only if the transaction commits.
// If the transaction fails, it will not run, which is usually what we want.
func (r *PGListenNotify) NotifyQuery(channel string, payload string) NotifyQueryResult {
	return NotifyQueryResult{
		Query:  "SELECT pg_notify($1, $2)",
		Params: []any{channel, payload},
	}
}

// startMonitoring begins the main monitoring loop for notifications.
func (r *PGListenNotify) startMonitoring() {
	// we are out of sync after the first wait and disconnections so let's avoid the first one.
	postFirstStartEver := false
	waitForNotificationAndInitiateListens := func(conn *pgxpool.Conn) error {
		justStartedWaits := true
		for {
			var outOfSyncCalls []ListenOptions
			r.lock.RLock()
			channelsChanged := r.channelsChanged
			r.lock.RUnlock()
			if channelsChanged || justStartedWaits {
				var addChannels []*ListenOptions
				var removeChannels []string
				r.lock.Lock()
				r.channelsChanged = false
				for _, options := range r.channels {
					if options.unListenRequested {
						removeChannels = append(removeChannels, options.channel)
					}
					if !options.executedListen || justStartedWaits {
						options.executedListen = true
						addChannels = append(addChannels, options)
					}
				}
				for _, channel := range removeChannels {
					if r.channels[channel].DoneCallback != nil {
						r.channels[channel].DoneCallback(channel)
					}
					close(r.channels[channel].unListenComplete)
					delete(r.channels, channel)
				}
				for _, options := range r.channels {
					outOfSyncCalls = append(outOfSyncCalls, *options)
				}
				r.lock.Unlock()
				if justStartedWaits {
					_, err := conn.Exec(r.ctx, fmt.Sprintf("LISTEN %s", pgx.Identifier{r.ownChannel}.Sanitize()))
					if err != nil {
						return fmt.Errorf("failed to listen on own channel: %w", err)
					}
				}
				for _, channelOptions := range addChannels {
					_, err := conn.Exec(r.ctx, fmt.Sprintf("LISTEN %s", pgx.Identifier{channelOptions.channel}.Sanitize()))
					if err != nil {
						r.safeCloseListeningStarted(channelOptions, err)
						return fmt.Errorf("failed to listen on channel %s: %w", channelOptions.channel, err)
					}
					r.safeCloseListeningStarted(channelOptions, nil)
				}
				if !justStartedWaits {
					for _, channel := range removeChannels {
						_, err := conn.Exec(r.ctx, fmt.Sprintf("UNLISTEN %s", pgx.Identifier{channel}.Sanitize()))
						if err != nil {
							return fmt.Errorf("failed to unlisten on channel %s: %w", channel, err)
						}
					}
				}
			}

			select {
			case <-r.ctx.Done():
				return nil
			default:
			}
			if postFirstStartEver {
				if justStartedWaits && len(outOfSyncCalls) > 0 {
					for _, options := range outOfSyncCalls {
						if options.OutOfSyncBlockingCallback != nil && !options.unListenRequested {
							err := options.OutOfSyncBlockingCallback(options.channel)
							if err != nil {
								return fmt.Errorf("out of sync callback failed for channel %s: %w", options.channel, err)
							}
						}
					}
				}
			} else {
				postFirstStartEver = true
			}
			select {
			case <-r.ctx.Done():
				return nil
			default:
			}
			n, err := conn.Conn().WaitForNotification(r.ctx)
			if err != nil {
				return fmt.Errorf("failed waiting for notification: %w", err)
			}
			r.lock.RLock()
			if options, ok := r.channels[n.Channel]; ok && !options.unListenRequested {
				if options.NotificationCallback != nil {
					options.NotificationCallback(n.Channel, n.Payload)
				}
			}
			r.lock.RUnlock()
			justStartedWaits = false
		}
	}

	acquireAndWait := func() error {
		select {
		case <-r.ctx.Done():
			r.callDoneCallbacks()
			return nil
		default:
		}
		conn, err := r.pool.Acquire(r.ctx)
		if err != nil {
			return fmt.Errorf("failed to acquire connection: %w", err)
		}
		defer conn.Release()
		return waitForNotificationAndInitiateListens(conn)
	}

	for {
		err := acquireAndWait()
		if err != nil {
			r.lock.RLock()
			for channel, options := range r.channels {
				if options.ErrorCallback != nil && !options.unListenRequested {
					options.ErrorCallback(channel, err)
				}
			}
			r.lock.RUnlock()
		}
		select {
		case <-r.ctx.Done():
			r.callDoneCallbacks()
			return
		case <-time.After(r.reconnectInterval):
		}
	}
}

// callDoneCallbacks invokes the DoneCallback for all channels.
func (r *PGListenNotify) callDoneCallbacks() {
	r.lock.RLock()
	defer r.lock.RUnlock()
	for channel, options := range r.channels {
		if options.DoneCallback != nil {
			options.DoneCallback(channel)
		}
	}
}

// safeCloseListeningStarted safely closes the listeningStarted channel
func (r *PGListenNotify) safeCloseListeningStarted(options *ListenOptions, err error) {
	options.listeningStartedMu.Lock()
	defer options.listeningStartedMu.Unlock()

	if !options.listeningStartedClosed {
		options.listeningStarted <- err
		close(options.listeningStarted)
		options.listeningStartedClosed = true
	}
}
